The following is a conversation with Greta van Rossum, creator of Python, one of the most popular programming languages in the world, used in almost any application that involves computers from Web back in development to psychology, neuroscience, computer vision, robotics, deep learning, natural language processing and almost any subfield of A.I.. This conversation is part of Mittie Course, an artificial general intelligence and the artificial intelligence podcast, if you enjoy it, subscribe on YouTube, iTunes or your podcast provider of choice, or simply connect with me on Twitter at Lex Friedman spelled F Outride.
And now here is my conversation with Guido Rassam.
You were born in the Netherlands in 1956, your parents in the world around you was deeply impacted by World War Two, as well as my family from the Soviet Union.
So with that context, well. What is your view of human nature? Are some humans inherently good and some inherently evil, or do we all have both good and evil within us? Ouch. I did not expect. Such a deep one, I I guess we all have good and evil potential in us, and a lot of it depends on.
Circumstances and context. Out of that world. At least on the civilian side in Europe, sort of out of suffering, out of challenge, out of that kind of set of traumatic events, often emerge as beautiful art, music, literature.
In an interview I read or heard, you said you enjoyed Dutch literature when when you were a child. Can you tell me about the books that had an influence on you in your childhood? Well, as a teenager, my favorite writer was my favorite Dutch author was a guy named William Frederick Hermance whose.
Writing, certainly his early novels were all about sort of. Ambiguous things that happened during World War Two, I think he was a young adult during that time and he wrote about it. A lot and very interesting, very good books, I thought, I think in a non-fiction way. No, it was all fiction, but it was very much set in in the ambiguous world of resistance against the Germans. Where often you could not tell whether someone. It was truly in the resistance or really a spy for the Germans and some of the characters in his novels sort of crossed that line and you never really find out what exactly happened.
And in his novels, there was always a good guy and a bad guy.
The nature of good and evil is it is clear there is a hero.
it is no his heroes are often more his main characters are often anti-heroes. And so they are they are not not very heroic. they are they are often they. They fail at some level to accomplish their lofty goals and looking at the trajectory through the rest of your life, has literature, Dutch or English or translation, and an impact outside the technical world that you existed in.
Hmm. I still read novels, I do not think that it. Impacts me that much directly, does not impact your work, it is just that it is a separate world. My work is is highly technical and sort of the the world of art and literature does not really directly have any bearing on it. You do not think there is a creative element to the design? You know, some would say the design of a language is art.
Uh. I am not disagreeing with that. I am just saying that sort of I do not feel direct influences from more traditional art on my own creativity.
All right.
Of course, you do not feel does not mean it is not somehow deeply there in your subconscious. We do not know.
Who knows? So let us go back to early teens. Your hobbies. War building, electronic circuits, building mechanical models. What if you can just put yourself back in the mind of that young, widowed 12, 13, 14, was that grounded in a desire to create a system so to create something or was it more just tinkering, just the joy of puzzle solving?
I think it was more the latter.
Actually, I. Maybe towards the end of my high school. Period, I felt confident enough that that I designed my own circuits that were sort of interesting. Somewhat. But a lot of that time, I literally just took a model kit and follow the instructions, putting the things together, I mean that I think the first few years that I build electronics kits, I really did not have enough understanding of sort of electronics to really understand what I was doing.
I mean, I could debug it and I could sort of follow the instructions very carefully, which has which has always stayed with me. But I had a very naive model of like how a transistor works. And I do not think that that in those days I had any understanding of coils and capacitors which which actually sort of. Was a major problem when I started to build more complex digital circuits because it was unaware of the sort of the analog part of the how they actually work.
And I would have things that.
The scheme, the schematic looked at everything looked fine and it did not work, and what I did not realize was that there was some megahertz level oscillation that was throwing the circuit off because I had a sort of two wires were too close or the switches were were kind of poorly built, but through that time.
I think it is really interesting and instructive to think about because there is echoes of Iraq in this time now, so in the 1970s, the personal computer was being born. So did you sense in tinkering with these circuits, did you sense the encroaching revolution in personal computing? So if at that point you are we see you down and ask you to predict the 80s and the 90s, do you think you would be able to do so successfully to unroll this, the process?
No, I had no clue. I.
I remember I think in the summer after my senior year, or maybe it was the summer after my junior year, well, at some point I think when I was 18, I went on a trip to the Math Olympiad in Eastern Europe and there was like I was part of the Dutch team and there were other nerdy kids that sort of had different experiences. And one of them told me about this amazing thing called a computer.
And I had never heard that word. My my own explorations in electronics were sort of about very simple digital circuits. And I I had sort of I had the idea that I somewhat understood how a digital calculator worked. And so there is maybe. Some echoes of computers there, but they did not, did not. I never made that connection. I did not know that when my parents were paying for magazine subscriptions, using punch cards, that there was something called a computer that was involved.
I read those cards and transferred money between accounts that was also not really interested in those things. It was only when I went to university to study math that I found out that they had a computer and students were allowed to use it. And there was some you are supposed to talk to that computer by programming it. What does that feel like? Yeah, that was the only thing you could do with it, that the computer was not really connected to the real world.
The only thing you could do was sort of you typed your program on a bunch of punched cards. You gave the punch cards to the operator, and an hour later, the operator gave you back your printout. And so all you could do was write a program that. Did something very abstract, and I do not even remember what my first forays into programming were, but. There were sort of doing simple math exercises and just to learn how a programming language worked.
Did you sense, OK, first year of college. You see this computer, you are able to have a program and it generates some output. Did you start seeing the possibility of this or was it a continuation of the tinkering with circuits? The did you start to imagine that one, the personal computer?
But did you see it as something that is a tool to get tool, like a word processing tool, maybe, maybe for gaming or something?
Or did you start to imagine it could be, you know, going to the world of robotics, like, you know, the Frankenstein picture, that you could create an artificial being.
there is like another entity in front of you.
You do not. I do not think I really saw it that way, I was really more interested in the tinkering. it is maybe not as sort of a complete coincidence that I ended up. Sort of.
Creating a programming language, which is a tool for other programmers, I have always been very focused on that sort of activity of programming itself and not so much what happens with with the program you write, right?
I do remember and I do not maybe in my second or third year, probably my second, actually. Someone pointed out to me that there was this thing called Conway's game of life, you are probably familiar with it. I think the 70s, I think, yeah, he came up with it, so there was a Scientific American column by. Someone who did a monthly column about mathematical diversions and also blinking out on the guy's name, it was very famous at the time and I think up to the 90s or so.
And one of his columns was about Conway's game of life. And he had some illustrations and he wrote down all the rules. And sort of there was the suggestion that this was philosophically interesting, that that was why Conway had called it that. And all I had was like the two pages photocopy of that article, I do not even remember where I got it. But it spoke to me and I remember implementing. A version of that game. For the Bache computer we were using where?
I hope Pa. program that sort of read an initial situation from input and read some numbers that that said do so many generations and print every so many generations and then out would come pages and pages of of sort of things, patterns of different kinds.
And yeah, yeah. And I remember much later I have done a similar thing using Python, but I would sort of that original version I wrote at the time I found interesting because I combined it with some trick I had learned during my electronics hobbyists times.
I essentially first on paper, I designed a simple circuit built out of logic gates that took nine bits of input, which is the sort of the cell and its neighbors, and produced a new value for that cell. And it is like a combination of of a half atter and some other clipping. You know, it is actually a full Aitor. And so I had worked that out. And then I translated that into a series of. Boolean operations on Pascal Integers, where you could use the integers as bitwise values and so I could basically generate 60 bits of a generation in in like.
Eight instructions or so nice. So I was proud of that. it is funny that you mention so for people who do not know, Conway's game of life is there is a cellular automata, whether it is single compute units that kind of look at their neighbors and figure out what they look like in the next generation based on the state of their neighbors. And it is deeply distributed system in concept at least. And then there is simple rules that all of them follow. And somehow out of the simple rule, when you step back and look at what occurs, it is beautiful.
there is a emergent complexity. Even though the underlying rules are simple, there is an emergent complexity.
Now, the funny thing is you have implemented this and the thing you are commenting on is you are proud of a hack you did to make it run efficiently. When you are not commenting on what is a beautiful implementation, you are not commenting on the fact that there is an emergent complexity that you have you have you have quoted a simple program.
And when you step back and you print out the following generation after generation, that is stuff that you may have not predicted would happen, is happening. Right. And there was that magic. I mean, that is the magic that all of us feel when we program, when you create a program and then you run it and whether it is hello world or shows something on screen, if there is a graphical component, are you seeing the magic in the mechanism of creating that?
I think it went back and forth as a student. We had an incredibly small budget of computer time that we could use.
It was actually measured. I once got in trouble with one of my professors because I had overspent the department's budget. it is a different story. But so. I actually wanted the efficient implementation because I also wanted to explore what would happen with a larger number of generations and a larger sort of size of the of the board. And so once the implementation was flawless, I would feed it different patterns and I think maybe there was a follow up article where there were patterns that that were like gliders, patterns that repeated themselves after a number of generations.
But I translated one or two positions to the right or up or something like that.
And there were I remember things like glider guns while you can you can Google Conway's game of life is still a people still go out and go over it for a reason because it is not really well understood why.
I mean, this is what Stephen Wolfram is obsessed about, OK? he is just the the we do not have the mathematical tools to describe the kind of complexity that emerges in these kinds of systems. And the only way you can do is to run it.
I am not convinced that that it is sort of a problem that lends itself to to classic mathematical analysis. No. And so one one theory of how you create an artificial intelligence or artificial being, you kind of have to stand with the game of life. You kind of have to create a universe and let it run that creating it from scratch in a designed way, in, you know, coding up a Python program that creates a faulty intelligence system may be quite challenging.
You might need to create a universe just like the game of life as. Well, you might have to experiment with a lot of different universes before there is a set of rules that does not essentially always just end up. Repeating itself in a truthful way. Yeah, and Steve Wolfram Stephen Wolfram works with these simple rules, says that it is kind of surprising how quickly you find rules that create interesting things you should not be able to, but somehow you do. And so maybe our universe is laden with with rules that will create interesting things.
They might not look like humans, but, you know, emergent phenomena that is interesting may not be as difficult to create as we think. Sure. But let me sort of ask at that time, you know, some of the world, at least in popular press, was kind of captivated, perhaps at least in America, by the idea of artificial intelligence, but that these computers would be able to think pretty soon.
And, yeah, that touched you at all. Did that in science fiction or in reality?
In in any way. I did not really start reading science fiction until much, much later. I think as a teenager, I I read maybe one bundle of science fiction stories. Was it in the background somewhere like in your thoughts that the sort of the using computers to build something intelligent always felt to me because I had I felt I had so much understanding of what actually goes on inside a computer, I I knew how many bits of memory it had and how difficult it was to program and.
Sort of. I did not believe at all that that you could just build something intelligent out of doubt that that would really sort of. Satisfy my definition of intelligence. I think the most the most influential thing that I read in my early 20s was Godel Escher, what that was about consciousness. And that was a big eye opener in some sense. In what sense, so, so, so, yeah, so on your own brain, did you do you did you at the time or do you now see your own brain as a computer or is there a total separation of the way?
So yeah, you are very pragmatically practically know the limits of memory, the limits of this sequential computing or weakly paralyzed computing. And you just know what we have now and it is hard to see how it creates, but it is also easy to see. It was in the 40s, 50s, 60s, and now at least similarities between the brain and our computers. Oh, yeah.
I mean, I. I totally believe that brains are. Computers, in some sense, I mean, the rules they they used to play by our pretty different from the rules we we can sort of implement in in our current hardware. But I do not believe in. Like a separate thing that infuses us with intelligence or consciousness or any of that, there is no soul. I have been an atheist probably from when I was 10 years old, just by thinking a bit about math and the universe.
And, well, my parents were atheists.
Uh. Now, I know that you could be an atheist and still believe that there is something sort of. About intelligence or consciousness that cannot possibly emerge from a fixed set of rules. I am not in that camp. I totally see that. Sort of, given how many millions of years evolution took its time, DNA is is a particular machine that that sort of. Encodes information and an unlimited amount of information in in chemical form and has figured out a way to replicate itself.
I thought that that was maybe it is 300 million years ago, but I thought it was closer to half a half a billion years ago that that sort of. Originated and it has not really changed that the sort of the structure of DNA has not changed ever since, that is like. Our binary code that we have in hardware, I mean, the basic programming language has not changed, but maybe the programming itself obviously did did not sort of it it happened to be a set of rules that was good enough to to sort of develop.
Endless variability and sort of the idea of self replicating molecules, competing with each other for resources and one time eventually sort of always taking over. that is happened before there were any fossils. So we do not know how that exactly happened, but.
I believe it is it is clear that that did happen and. Can you comment on consciousness and how you see it, because I think we will talk about programming quite a bit. we will talk about, you know, intelligence connecting to programming fundamentally. But consciousness, consciousness is this whole other thing. Do you think about it often as a developer of a programming language and and as a human?
Those those are pretty sort of separate topics. My sort of my line of work working with programming. Does not involve anything that that goes in the direction of developing intelligence or consciousness, but sort of privately as an avid reader of popular science writing.
I have some thoughts which which is mostly that. I do not actually believe that consciousness is an all or nothing thing. I have a feeling that and I forget what I read that influenced this, but. I feel that if you look at a cat or a dog or a mouse, they have some form of intelligence. If you look at a fish, it has some form of intelligence and. That evolution just took a long time, but I feel that the sort of evolution of.
More and more intelligence that led to to sort of the human form of intelligence followed the evolution of. The census, especially the visual census. I mean, there is an enormous amount of processing that is needed to interpret a scene and humans are still better at that than than computers are. Yeah, and so and I have a feeling that. There is a sort of. The reason that that like mammals is in particular developed. The levels of consciousness that they have and that eventually reached sort of from going from intelligence to to self-awareness and consciousness has to do with sort of being a robot that has very highly developed senses, has a lot of rich sensory information coming in.
So that is a really interesting thought that the that whatever that basic mechanism of DNA, whatever that basic building blocks of programming is, if you just add more abilities, more more high resolution sensors, more sensors, you just keep stacking those things on top, that this basic programming in trying to survive develops very interesting things that start towards humans to appear like intelligence and consciousness.
Yeah. So as far as robots go, I think that the self-driving cars have that sort of. The greatest opportunity of developing something like that because. When I drive myself, I do not just pay attention to the rules of the road. I also look around and I get clues from that, oh, this is a shopping district. Oh, here is an old lady crossing the street. Oh, here is someone carrying. A pile of mail, there is a mailbox that you they are going across the street to reach that mailbox and I slow down and I do not even think about that.
Yeah, and so there is there is so much. Where you turn your observations into an understanding of what utter consciousnesses are going to do or what what other systems in the world are going to be, oh, the tree is going to fall.
Mm hmm. Yeah, I see.
Sort of. I see much more. I expect somehow that if anything is going to become conscious, it is going to be the self-driving car and not the network of a bazillion. Computers at Google or Amazon Data Center that are all networked together to do whatever they do.
So in that sense, so you actually highlight that is what I work in, an autonomous vehicles.
You highlight a big gap between what we currently can not do and what we truly need to be able to do to solve the problem under that formulation. And consciousness and intelligence is something that basically a system should have in order to interact with us humans. As opposed to some kind of abstract notion of a consciousness, consciousness is something that you need to have to be able to empathize, to be able to fear the understand what the fear of death is.
All these aspects that are important for interacting with pedestrians need to be able to do basic computation based on our human desires and thoughts.
Sort of, yeah. If you if you look at the dog, the dog clearly knows. I mean, I am not a dog owner, but I have friends who have dogs. The dogs clearly know what the humans around them are going to do, or at least they have a model of what those humans are going to do. And they learn that some dogs know when you are going out and they want to go out with you, they are sad. When you leave them alone, they cry.
they are afraid because they were mistreated when they were younger. We we do not assign sort of consciousness to dogs, or at least not not all that much, but I also do not think they have none of that. So I think it is. Consciousness and intelligence are not all or nothing. The spectrum is really interesting, but in returning to. Programming languages in the way we think about building these kinds of things about building intelligence, building consciousness, building artificial beings, I think one of the exciting ideas came in the 17th century and with liveness, Hobbs, Descartes, where there is this feeling that you can convert.
All thought, all reasoning, all the things that we find very special in our brains, you can convert all that into logic so you can formalize it formal reasoning. And then once you formalize everything of knowledge, then you can just calculate. And that is what we are doing with our brains as we are calculating.
So there is this whole idea that we know that this is possible, that they were not aware of the concept of pattern matching in the sense that we are aware of it now. They sort of thought they had discovered incredible bits of mathematics like Newton's calculus and dare sort of idealism. they are their sort of extension of what they could do with logic and math, sort of. Went along those lines and they thought. There there is like, yeah, logic there is there is like a bunch of rules and a bunch of input, they did not realize that how you recognize a face is not just a bunch of rules, but it is a shit ton of data plus a circuit that that sort of interprets the visual clues and the context and everything else and somehow can massively parallel pattern match against stored rules.
I mean, but if I see you tomorrow here in front of the Dropbox office, I might recognize you even if I am wearing a different shirt. Yeah, but if I if I see you tomorrow in a coffee shop in Belmont, I might have no idea that it was you or on the beach or whatever. And I make those kind of mistakes myself all the time. I see someone that I only know as like, oh, this person is a colleague of my wife's.
And then I see them at the movies and I do not recognize them.
But do you see those you call a pattern matching? Do you see that rules as. Unable to encode that to you, everything you see, all the pieces of information you look around this room, I am wearing a black shirt, I have a certain height, I am a human.
All these there is probably tens of thousands of facts you pick up moment by moment about this scene.
You take them for granted and you accumulate aggregate them together to understand this thing. You do not think all that could be encoded to warrant. At the end of the day, you can just put on the table and calculate. Well, I do not know what that means. I mean. Yes, in the sense that there is no there there is no actual magic there, but there are enough layers of abstraction from sort of from the facts as they enter my eyes and my ears to the understanding of the scene, that I do not think that.
That A.I. has really covered enough of of. Of that distance, it is like if you take a human body and you realize it is built out of atoms, well, that that is a uselessly reductionist view. Right, right. The body is built out of organs. The organs are built out of cells. The cells are built out of proteins. The proteins are built out of amino acids. The amino acids are built out of atoms. And then you go to quantum mechanics.
So that is a very pragmatic view. I mean, obviously, as an engineer, I agree with that kind of view. But you also have to consider the the with the Sam Harris view of, well, intelligence is just information processing.
he is just like you said, you taking sensory information, you do some stuff with it, and you come up with actions that are intelligent. Let me he makes it sound so easy, I do not know who Sam Harris is, a philosopher. So like this how philosophers often think, right? Essentially, that is what Descartes was. Wait a minute.
If there is, like you said, no magic. So he basically says it does not appear like there is any magic, but we know so little about it. That it might as well be magic, so just because we know that we are made of atoms, just because we know we are made of organs, the fact that we know very little how to get from the atoms to organs in a way that is regrettable means that you should not get too excited just yet about the fact that you figured out what we are made of atoms.
Right.
And and and the same about taking facts as are our sensory organs. Take them in. And turning that into reasons and actions. That sort of there are a lot of abstractions that we have not quite figured out how to how to deal with those, I mean, I. So sometimes. I do not know if I can go on a tangent or not to drag you back in. Sure. So if I take a simple program that passes a say, I have a compiler.
It parses the program in a sense, the input routine of that compiler, of that parser. Is a sense, a sense in Oregon, and it builds up a mighty complicated internal representation of the program. Just saw it does not just have a linear sequence of bytes representing the text of the program anymore. It has an abstract syntax tree. And I do not know how many of your viewers or listeners are familiar with compiler technology, but there is fewer and fewer these days, right?
that is also true, probably. People want to take a shortcut, but there is sort of this abstraction is a data structure that is the compiler then uses to produce outputs that is relevant like a translation of the program to machine code that can be executed by by hardware. And then that data structure gets thrown away. When a fish or a fly sees. Sort of gets visual impulses. I am sure it also builds up some data structure and for the fly, that may be very minimal, a fly may may have only a few.
I mean, in the case of a fly's brain, I could imagine that there are. Few enough layers of abstraction that it is not much more than when it is darker here than it is here. Well, I can sense motion because of fly sort of response when you move your arm towards it so clearly. it is visual processing is intelligent, well, not intelligent, but has been an abstraction for motion, and we still have similar things in in but much more complicated in our brains.
I mean, otherwise, you could not drive a car if you you could not if you did not have an incredibly good abstraction for motion. Yeah, in some sense, the same attraction for motion is probably one of the primary sources of our information for us, we just know what to do. I think we know what to do with that. we have built up other obstructions on top.
we have much more complicated data structures based on that. And we build more persistent data structures sort of after some processing, some information sort of gets stored in our memory pretty much permanently and is available on recall. I mean, there are some things that you sort of. you are conscious that you are remembering it like you give me your phone number, I well, at my age I have to write it down, but I could imagine I could remember those seven numbers or ten, 10 digits and reproduce them in a while if I sort of repeat them to myself a few times.
So that is a fairly conscious form of memorization. On the other hand, how do I recognize your face? I have no idea. My brain has a whole bunch of specialized hardware that knows how to recognize faces. I do not know how much of that is sort of coded in our DNA and how much of that is trained over and over between the ages of zero and three. But but but somehow our brains know how to do lots of things like that that are useful in our interactions with with other humans, with without really being conscious of how it is done anymore.
Right. So what our actual day lives were operating at the very highest level of abstraction. we are just not even conscious of all the little details underlying it.
there is compilers on top of things like turtles on top of turtles or turtles all the way down, compilers all the way down.
But that is essentially you say that there is no magic. that is what. I what I was trying to get at, I think, is with the started this whole train of saying that there is no magic. I mean, there is all this before.
Well, then the cards also have the notion, though, that the soul and the body were were fundamentally separate.
Yeah, I think he had to write in God in there for political reasons. So I do not actually I am not historian, but there is notions in there that all of reasoning, all of human thought can be formalized.
I think that continued in the 20th century with with the Russell and with with Gaydos and Completeness Theorem, this debate of what what what are the limits of the things that could be formalised. that is where the Turing machine came along. And this exciting idea, I mean, underlying a lot of computing that you can do quite a lot with a computer.
You can you can encode a lot of the stuff we are talking about in terms of recognizing faces and so on, theoretically in an algorithm that can then run on the computer.
And in that context, I would like to ask programming in a. Philosophical way, what so what what does it mean to program a computer? So you said you write a Python program or compiled a C++ program that compiles to some bytecode. it is forming layers, you are programming a layer of abstraction that is higher, how do you see programming in that context? Can it keep getting higher and higher levels of abstraction? I think and at some point, the higher level of levels of obstruction will not be called programming and they will not resemble what we what we call programming at the moment, there will not be source code.
I mean, there will still be source code, sort of. At a lower level of the machine, just like there are still molecules and electrons and sort of proteins in our brains, but and so there are still. Programming and system administration and who knows what, keeping to keep the machine running, but what the machine does is, is a different level of abstraction in a sense. And as far as I understand the way that. For the last decade or more, people have made progress with things like facial recognition or the self-driving cars is all by endless, endless amounts of training data where.
At least as as as a layperson, and I feel myself totally as a layperson in that field, it looks like. The researchers who published the results do not necessarily know exactly how how their algorithms work at. I often get upset when I sort of read sort of a fluff piece about Facebook in the newspaper or social networks, and they say, well, algorithms, and that is like totally different. Interpretation of the word algorithm, because for me. The way I was trained or what I learned when I was eight or 10 years old, an algorithm is a set of rules that you completely understand that can be mathematically analyzed and you can prove things you can like prove that er Stastny Civ produces all prime numbers and only prime numbers.
Yeah. So the I do not know if you know Vaudrey Carpathians. I am afraid not. So he is head of Aiyah Tesla now, but he is at Stanford before and he has this cheeky way of calling this concept Software 2.0 to disentangle that for a second.
So, so kind of what you are referring to is the traditional traditional via the algorithm, the concept of an algorithm, something that is there is clear.
You can read it. You understand. You can prove it is functioning as kind of software 1.0. And what Software 2.0 is, is exactly what you describe, which is you have neural networks, which is a type of machine learning that you feed a bunch of data and that neural network learns to do a function. And all you specify is the inputs in the outputs you want and you can not look inside, you can not analyze it. All you can do is train this function to map the inputs, the outputs by giving a lot of data.
And that sense programming becomes getting a lot of cleaning, getting a lot of data. that is what programming is in as well.
That would be Programming 2.0 2.0 to Programming 2.0, and I would not call it that programming.
it is just a different activity. Just like building organs out of cells is not called chemistry.
Well, so let us just step back and think sort of more generally, of course. But, you know, it is like.
As a parent, teaching teaching your kids things can be called programming in that same sense, that that is how programming is being used, you are providing them data, examples, use cases. So imagine writing a function not by. Not with four loops and clearly readable text, but more saying, well, here is a lot of examples of what this function should take and here is a lot of examples of when it takes those functions. It should do this and then figure out the rest.
So that is the 2.0 concept.
And the question I have for you is like it is a very fuzzy way.
This is the reality of a lot of these pattern recognition systems.
So it is a fuzzy way of, quote unquote, programming. What do you think about this kind of world? It should be called something totally different than programming if you are a software engineer. Does that mean you are you are designing systems that are very can be systematically tested and evaluated, have a very specific specification, and then this other fuzzy Software 2.0 world machine learning world, that that is something else? Totally. Or is there some intermixing that it is possible? Well, the question is probably only being asked because we we do not quite know what that Software 2.0 actually is, and it sort of I think there is a truism that every task that A.I. has has tackled in the past, at some point we realized how it was done and then it was no longer considered part of artificial intelligence because it was no longer necessary to to use that term.
It was just, oh, now we know how to do this. And a new field of science or engineering has been developed. And I do not know if sort of every form of learning or sort of controlling computer systems should always be called programming. So that I do not know, maybe I am focused too much on the terminology, but I expect that.
That there just will be different concepts where people with. Sort of different education and a different model of what they are trying to do. I will will develop those concepts, and I guess if you could comment and another way to put this concept is I think. I think the kind of functions that neural networks provide is things as opposed to being able to up front prove that this should work for all cases you throw at it. All year, it is the worst case analysis versus average case analysis, all you able to say is it is it seems on everything we have tested to work ninety nine point nine percent of the time, but we can not guarantee it.
And it. It fails in unexpected ways. Can even give you examples of how it fails in unexpected ways, but it is like really good most of the time. Yeah, but there is no room for that in current ways. We think about programming. Uh. Programming 1.0 is actually sort of. Getting to that point to where there is sort of the ideal of a bug free program. Has been abandoned long ago by most software developers. We only care about.
Bugs that manifest themselves often enough to be annoying. And we are willing to take the occasional crash or outage or incorrect result. Mm hmm. Uh. For granted, because we can not possibly we do not have enough programmers to make all the code bug free, and it would be an incredibly tedious business, and if you try to throw formal methods at it, it gets it becomes even more tedious. So every once in a while, the user clicks on a link in and somehow they get an error and the average user does not panic.
They just. Click again and see if it works better the second time, which often magically it does, or they go up and they try some other way of performing their tasks. So that is sort of an end to end recovery mechanism. And inside systems, there is all sorts of retries and time outs and fallbacks. And I imagine that that sort of biological systems are even more full of that because otherwise they would not survive. Do you think programming should be taught and thought of as exactly what you just said?
I come from as kind of you are always denying that fact, always in the sort of basic programming education. The sort of the programs your you are having students, right, are so small and simple that. If there is a bug, you can always find it and fix it, because the sort of programming as it is being taught in some even elementary middle schools in high school. Introduction to programming classes in college, typically its programming in the small room, very few classes sort of actually teach software engineering, building large systems, I mean.
Every summer here at Dropbox, we have a large number of interns, every tech company on the West Coast has the same thing.
These interns are always amazed because this is the first time in their life that they see what goes on in a really large software development environment.
And everything they have learned in college was almost always about a much smaller scale, and somehow that difference in scale makes a qualitative difference in how you how you do things and how you think about it.
If you then take a few steps back into decades, 70s and 80s when you are first thinking about Python or just that world of programming languages. Did you ever think that there would be systems as large as underlying Google, Facebook and Dropbox? Did you when you were thinking about.
Python, I was actually always caught by surprise by this. Yeah, pretty much every stage of computing.
So maybe just because you spoke in other interviews, but I think the evolution of programming languages are fascinating. it is especially because it leads, from my perspective, towards greater and greater degrees of intelligence. I learned the first programming language I played with in Russia was with the turtle logo logo.
Yeah.
And if you look, I just have a list of programming languages, all of which I know played with a little bit. I mean, they are all beautiful in different ways from Fortran, COBOL, Lisp, Algol 60 basic log and see as a few object oriented came along in the 60s. Simular Pasko small talk.
All of that lead. All the classics. The classics. Yeah, the classic hits. Right Scheme A built that is built on top of Lisp at. On the database, Itescu, URL's, C++, and all that leads up to Python, Haskell to. And that is before Python Matlab, these kind of different communities, different languages, so can you talk about that world? I know that sort of python came out of ABC, which actually never knew that language.
I just having researched this conversation, went back to ABC.
And it looks remarkably it it has a lot of annoying qualities, but underneath those like all caps and so on. But underneath that, there is elements of Python that are quite there already there.
that is where I got all the good stuff, all the good stuff.
So but in that world, you are swimming in these programming language where you focused on just the good stuff in your specific circle, or did you have a sense of what what is everyone chasing? You said that every programming language is built. Scratch an itch.
Mm hmm.
Were you aware of all the issues in the community? And if not, or if. Yes.
I mean, what if we tried to scratch with Python?
Well, I am glad I was not aware of all the issues because I would probably not have been able to do anything. I mean, if you are trying to solve every problem at once, you saw nothing.
Well, yeah, it is it is too overwhelming. And so I had a very, very focused problem. I wanted a programming language that said. Somewhere in between she will scripting and see. And now. Arguably, there is like one is higher level, one is lower level. And. Python is sort of. A language of an intermediate level, although it is still pretty much at the high level and. No, I was I was thinking about much more about.
I want a tool. That I can use to be more productive as a programmer in a very specific environment. And I also had given myself a time budget for the development of the tool, and that was sort of about three months for both the design, like thinking through what are all the features of the language syntactically and semantically, and how do I implement the whole pipeline from parsing the source code to executing it.
So I think both with the timeline and the goals, it seems like productivity was at the core of it as a goal.
So. Like for me, in the 90s and the first decade of the 21st century, I was always doing machine learning I programming for my research was always in C++. And then and then the other people who are a little more mechanical engineering, electrical engineering are our matlab that a little bit more matlab focus. Those are the world and maybe a little bit Java, too.
But the people who are more interested in and emphasizing the object oriented nature of things.
So but in the last 10 years or so, especially with the on coming of neural networks in these packages that are built on Python to interface with with the neural networks, I switched to Python and it is just. I have noticed a significant boost that I can not exactly, because I do not think about it, but I can not exactly put into words why I am just much, much more productive just being able to get the job done much, much faster.
So how do you think whatever that qualitative difference is? I do not know if it is quantitative. It could be just a feeling. I do not know if I am actually more productive. But how do you think you are? Yeah, well, that is right. I think there is elements and you speak to one aspect. I think those was the fact that productivity is Cyprus was was I really enjoyed creating performant code and creating a beautiful structure where everything that, you know, this kind of going into this, especially with the newer, newer standards of templated programming, of just really creating this beautiful formal structure that I found myself spending most of my time doing that, as opposed to getting a parsing a file and extracting a few keywords or whatever the task of trying to do.
So what is it about Python? How do you think of productivity in general as you were designing it now sort of through a decades past three decades? What do you think it means to be a productive programmer? And how did you try to design it into the language? There are different tasks, and as a programmer, it is it is useful to have different tools available that sort of are suitable for different tasks. So I still write C-code, I still write code, but I write most of my my things in Python.
Why do I still use those other languages, because sometimes the task just demands it. And well, I would say most of the time, the task actually demands a certain language because the task is not right, a program that solves problem X from scratch, but it is more like fix a bug in existing program X or add a small feature to an existing large program.
But. Even if if you sort of. If you are not constrained in your choice of language by context like that. There is still the fact that if you write it in a certain language, then you sort of. You you have this balance between how long does it time, does it take you to write the code and how long does the code run? Right, and. When you are in sort of. In the phase of exploring solutions, you often spend much more time writing the code than running it, because every time you have sort of you have run it, you see that the output is not quite what you wanted and you spend some more time coding.
And a language like Python just makes that iteration much faster because there are fewer details. There is a large library, uh, sort of there are fewer details that that you have to get right before your program compiles and runs. Uh, there are libraries that do all sorts of stuff for you, so you can sort of very quickly. Take a bunch of existing components, put them together and get your prototype application running, just like when I was building electronics, I was using a breadboard most of the time.
So I had this, like, sprawled out circuit that. If you shook it, it would stop working because it was not put together very well, but. It functioned and all I wanted was to see that it worked and then move on to the next next schematic or design or add something to it, once you have sort of figured out, oh, this is the perfect design for my radio or light sensor or whatever, then you can say, OK, how do we design a PCB for this?
How do we sell to the components in a small space? How do we make it so that it is robust against, say, voltage fluctuations or mechanical disruption? I mean, I know nothing about that when it comes to designing electronics, but I know a lot about that when it comes to to writing code.
So the initial initial steps are efficient, fast, and there is not much stuff that gets in the way. But you are kind of describing. From Darwin described the evolution of species right to your observing of what is about true about Python.
Now, if you take a step back, if the art of if the act of creating languages is art and you had three months to do it, initial steps, and so you just specified a bunch of goals, sort of things that you observe about Python, perhaps you had those goals, but how do you create the rules, the syntactic structure, the the features that result in those? So I have in the beginning and I have follow up questions about through the evolution of Python two.
But in the very beginning, when you are sitting there creating the lexical outlines or whatever, evolution was still a big part of it because.
I, I sort of. I said to myself, I do not want to have to design everything from scratch, I am going to borrow features from other languages that I like. Oh, interesting. So you basically. Exactly. You first observe what you like.
Yeah. And so that is why if you are 17 years old and you want to sort of create a programming language, you are not going to be very successful at it. Because you have no experience with other languages, whereas I was in my. let us say mid 30s. I had written parsers before, so I had worked on the implementation of ABC. I had spent years debating the design of ABC with its authors. it is with its designers. I had nothing to do with the design.
It was designed fully as it ended up being implemented when I joined the team. But so. You borrow ideas and concepts and very concrete sort of local rules from different languages like the indentation and certain other syntactic features from ABC, but I chose to borrow string literals and how numbers work from C and various other things. So even then, if you take that further. So yet you have had this funny sounding, but I think surprisingly accurate and or at least practical title of benevolent dictator for life for quite, you know, for the last three decades or whatever or.
No, not the actual title, but functionally speaking.
So you had to make decisions. Design decisions. Can you maybe let us take Python to Python releasing Python three as an example? Hmm. it is not backward compatible to Python too, in ways that a lot of people know.
So what was that deliberation, discussion, decision like? We have what was the psychology of that experience?
Do you regret any aspects of how that experience undergone that? Well, yeah. So it was a group process really at that point, even though I was beadell in NIM in name and certainly everybody sort of respected my my position as the creator and the current sort of owner of the language design. I was looking at everyone else for feedback. Sort of Python 3.0 in some sense, was sparked by other people in the community pointing out. Oh, well, there are a few issues that.
Sort of bite users over and over, can we do something about that? And for Python three, we took a number of those Python wards, as they were called at the time, and we said, can we try to sort of make small changes to the language that address those warts? And we had sort of in the past, we had always. Taken backwards compatibility very seriously, and so many Python words in earlier versions had already been resolved because they could be resolved while maintaining backwards compatibility or sort of using a very gradual path of evolution of the language in a certain area.
And so we were stuck with a number of words that were widely recognized as problems, not like roadblocks, but nevertheless sort of things that some people trip over. And you know, that that is always the same thing that that people trip over when they trip. And we could not think of a backwards, compatible way of resolving those issues. But it is still an option to not resolve the issues. And so, yes, for for a long time, we had sort of resigned ourselves to, well, OK, the language is not going to be perfect in this way and that way and that way.
And we sort of. Certain of these I mean, there are still plenty of things where you can say, well, that is that particular detail is better in Java or in R or in visual, basic or whatever.
Uh. And we are OK with that because, well, we can not easily change it. it is not too bad we can do a little bit with user education or we can have a static analyzer or warnings in in the past or something. But there were things where we thought, well, these are really problems that are not going away. they are getting worse in the future. We should do something about it, do something, but ultimately there is a decision to be made, right?
Yes, so.
Was that the toughest decision in the history of Prytania to make as the benevolent dictator for life, or if not, what are there maybe even on the smaller scale, what was the decision where you were really torn up about?
Well, the toughest decision was probably to resign.
All right. let us go there for a second, then. Let me just because in the interest of time, too, because I have a few questions for you and let us touch a really important one, because it was quite dramatic and beautiful and certain kinds of ways. In July this year, three months ago, you wrote Now that Pep 572 is done, I do not ever want to have to fight so hard for a pep and find that so many people despise my decisions.
I would like to remove myself entirely from the decision process. I will still be there for a while as an ordinary core developer, and I will still be available to mentor people, possibly more available. But I am basically giving myself a permanent vacation from being Wiedefeld benevolent dictator for life, and you all will be on your own.
First of all, it is just this. it is it is almost Shakespearean.
I am not going to appoint a successor. So what are you all going to do? Create a democracy, anarchy, a dictatorship, a federation. So that was a very dramatic and beautiful. A set of statements, it is almost that is open ended nature called the community to create a future for Python.
This is kind of a beautiful aspect to it. Wow.
So. What and dramatic, you know, what was making that decision, like, what was on your heart, on your mind, stepping back now a few months later, we could take you into your mind.
I am glad you like the writing because it was actually written pretty quickly. It was literally something like. After months and months of. Going around in circles. I had finally. Approved five seventy two, which I had a big hand in its design, although I did not initiate. It originally I sort of gave it a bunch of nudges in a direction that would be better for the language so, so, so, so sorry just to ask.
it is async I. Oh, no, no, no, no. Five seventy two was actually a small feature, which is assignment expressions of silent expressions that had been. There was just a lot of debate where a lot of people claimed that. They knew what was Pythonic and what was not Pythonic, and they knew that this was going to destroy the language. This was like a violation of Python's most fundamental design philosophy. And I thought that was all bullshit because I was in favor of it.
And then I would think I know something about Python's design philosophy. So I was really tired and also stressed of that thing. And literally after sort of announcing I was going to accept it. A certain Wednesday evening, I had finally sent the email, it is accepted now let us just go implement it. So I went to bed feeling really relieved that is behind me and I wake up Thursday morning. 7:00 a.m. and I think. Well, that was the last one.
that is going to be such. Such a terrible debate and that is it going to be. that is the last time that I let myself be so stressed out about Apep decision. Yeah, I should just resign. I have been sort of thinking about retirement for half a decade. I have been joking and sort of mentioning retirement, sort of telling the community at some point in the future, I am going to retire. do not take that F.L. part of my title too literally. And I thought, OK, this is it, I am done.
I had the day off. I wanted to have a good time with my wife. We were going to a little beach town nearby and in I think maybe 15, 20 minutes I wrote that thing that you just called Shakespearean.
And the funny thing is going to get so much crap for calling a Shakespearean. I did not even I did not even realize what a monumental decision it was, because five minutes later, I read that link to my message back on Twitter. Where people were already discussing on Twitter, Guido resigned as the beadell, and I had I had posted it on an internal forum that I thought was only read by core developers. So I thought I would at least have one day before it news would sort of get out.
The onion aspects had also an element of quite. it is quite a powerful element of the uncertainty that lies ahead, but can you also just briefly talk about, you know, like, for example, I play guitar as a hobby for fun, and whenever I play, people are super positive, super friendly. they are like, this is awesome. This is great. But sometimes I enter as an outside observer, enter the program and community, and there seems to sometimes be camps and whatever the topic and and the two camps, the two plus camps are often pretty harsh in criticizing the opposing camps.
As an onlooker, I may be totally wrong on this whole thing, like wars are sort of a favorite activity in the programming community. And what is the psychology behind that? Is is that OK for healthy community to have? Is that is that a productive force ultimately for the evolution of a language?
Well, if everybody is betting each other on the back and never telling the truth, yes, it would not be a good thing. I think there is a middle ground where. Sort of. Being nasty to each other is not OK, but there there is is is a middle ground where there is healthy ongoing criticism and feedback that is very productive. And you mean at at every level you see that I mean, someone proposes to fix a very small issue in a code base, chances are that some reviewer will sort of respond by saying, well, actually, you can do it better the other way.
Right. And when it comes to deciding on the future of the Python core developer community that we now have, I think, five or six competing proposals for a constitution. So that future do you have a fear of that future, do you have a hope for their future? I am very confident about that future, it by and large, I think that the debate has been very healthy and productive and I actually when when I wrote that resignation. Email, I knew that that Python was in a very good spot and that the Python core development community, the group of 50 or 100 people who sort of write or review most of the code that goes into Python, those people gets along very well most of the time.
And a large number of different areas of expertise are represented at. Different levels of experience in the Pyfrom core deaf community, different levels of experience completely outside it in software development in general, large systems, small systems, embedded systems, so. I I felt OK resigning because I knew that the community can really take care of itself. And out of a grab bag of future future developments, let me ask if you can comment maybe on all very quickly concurrent programming, parallel computing, async IO, these are things that people have expressed hope, complained about whatever have discussed on Reddit async.
I also the parallelization general packaging. I was totally clueless on this. I just used to style stuff. But apparently there is paper and poetry. there is these dependancy packaging systems that manage dependency and so on that are emerging. And there is a lot of confusion about what is what is the right thing to use.
Then also functional programming.
The the ever you know, the I we are going to get more functional programming or not this kind of this kind of idea. And of course, the the Guille as a connected to the parallelization as opposed to global interpretor lock problem. Can you just comment on whichever you want to comment on?
Well, let us take the Guille and Paralyzation and AC and COYO as one one topic. I am not that hopeful that Python will develop into a sort of high concurrency, high parallelism language that sort of the the way the language is designed, the way most users use the language, the way the language is implemented, all make that a pretty unlikely future.
So you think it might not even need to really the way people use it, it might not be something that should be of great concern. I think I think async I o is a special case because it sort of allows overlapping Io and only IO, and that is is a sort of best practice of supporting very high throughput IO. Many connections per second. I am not worried about that, I think async I will evolve. There are a couple of competing packages.
We have some very smart people who are sort of pushing us in sort of to make a better parallel computing. I think that Python is not the language for that. There are there are ways to work around it. But you sort of you can not expect to write. An algorithm in Python and have a compiler automatically paralyzed that what you can do is use a package like NUM Pi and there are a bunch of other very powerful packages that sort of use all the CPU's available because you tell the package, here is the data.
here is the abstract operation to apply over a go at it. And then then we are back in the C++ world. But those packages are themselves implemented, usually in C++.
that is right. that is that is where Tenzer, following all these packages come in, where they paralyzer used, for example, they take care of that. So in terms of packaging, can you comment on the packaging and might it?
Packaging has always been my least favorite topic. it is it is it is a really tough problem because the OS and the platform want to own packaging. Mm hmm. Uh. But their packaging solution is not specific to a language like if you take Linux, there are two competing packaging solutions for Linux or for Unix and in general, and but they all work across all languages and several languages like Noad, JavaScript and Ruby and Python all have their own packaging solutions that only work within the ecosystem of that language.
Well, what should you use?
That is a tough problem, my own own approach is I use the system packaging system to install Python and I use the Python packaging system then to install a third party Python packages. that is what most people do. Ten years ago, Python packaging was really a terrible situation. Nowadays, Pip is the future. There is there is a separate ecosystem for numerical and scientific python python based on anakonda. Those two can live together. I do not think there is a need for more than that.
Great. So that is that is packaging.
that is well, at least for me, that is that is why I have been extremely happy. I did not I did not even know this was an issue until I was brought up. Well, in the interest of time, let me sort of skip through a million other questions I have.
So I watched the five hour, five, five and a half hour oral history they have done with the Computer History Museum. And the nice thing about it, it gave this because of the linear progression of the interview. It gave this feeling of a life, you know, a life well lived with interesting things in it. Um, sort of a pretty, I would say, a good spend of of this little existence we have on Earth. So outside of your family, looking back, what about this journey are you really proud of?
There are moments that stand out, accomplishments, ideas. Is it the creation of Python itself that stands out as a thing that you look back and say, damn, I did pretty good there. Well, I would say that Python is definitely the best thing I have ever done. And I would not sort of say just the creation of Python, but the way I sort of raised Python like a baby, I did not just conceive a child, but I raised a child.
And now I am setting the child free in the world and I have set up the child to to sort of be able to take care of himself. And I am very proud of that.
And as the announcer of Monty Python's Flying Circus used to say, and now for something completely different, do you have a favorite Monty Python moment or a moment, Hitchhiker's Guide or any other literature show movie that cracks you up when you think about it?
You can always blame me, the parents, the dead parrot sketch. Oh, that is brilliant. Yeah, that is my favorite as well, pushing up the daisies. OK, great. Thank you so much for talking with me today. it is been a great conversation.
